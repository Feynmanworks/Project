int p=0;
int audio[]= ;
int threshold = ;  //measured by micro sensor in silence and computed by Matlab

for(int i=0; i<len; i++){
    p += audio[i]*audio[i];
}

if (p > threshold){




    // Temp Sensor
      #define lm35 28                  //
      float value_temp=0.0;
      
      void setup() {
        pinMode(lm35, INPUT);
        Serial.begin(9600);
        pinMode(RED_LED, OUTPUT);
        pinMode(GREEN_LED, OUTPUT);
        pinMode(BLUE_LED, OUTPUT);
      }
      
      void loop() {
        value_temp  = analogRead(lm35);
        float tamp_F = ((value_temp*3.3)/4096.0)*100;
        float tamp_C = (((value_temp*3.3)/4096.0)*100-32)/1.8;
      
        if (tamp_F > 100) {
          digitalWrite(RED_LED, HIGH);
          digitalWrite(GREEN_LED, LOW);
          digitalWrite(BLUE_LED, LOW);
        } 
        if ( 20<= tamp_F <= 100) {
          digitalWrite(RED_LED, LOW);
          digitalWrite(GREEN_LED, HIGH);
          digitalWrite(BLUE_LED, LOW);
        } 
        if( tamp_F < 20){
          digitalWrite(RED_LED, LOW);
          digitalWrite(GREEN_LED, LOW);
          digitalWrite(BLUE_LED, HIGH);
        }
      
        Serial.print("Tempetature is:  ");
        Serial.print(tamp_F);
        Serial.print("°F  ");
        Serial.print(tamp_C);
        Serial.println("°C  ");
        delay(1000);
      }


const int sampleWindow = 50;  // Sample window width in mS (50 mS = 20Hz)
int const AMP_PIN = A1;       // Preamp output pin connected to A0
unsigned int sample;

void setup()
{
  pinMode(RED_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);
  pinMode(BLUE_LED, OUTPUT);
  Serial.begin(9600);
}

void loop()
{
  unsigned long startMillis = millis(); // Start of sample window
  unsigned int peakToPeak = 0;   // peak-to-peak level

  unsigned int signalMax = 0;
  unsigned int signalMin = 4095;

  // collect data for 50 mS and then plot data
  while (millis() - startMillis < sampleWindow)
  {
    sample = analogRead(AMP_PIN);
    if (sample < 4096)  // toss out spurious readings
    {
      if (sample > signalMax)
      {
        signalMax = sample;  // save just the max levels
      }
      else if (sample < signalMin)
      {
        signalMin = sample;  // save just the min levels
      }
    }
     if (sample > 3500) {
    digitalWrite(RED_LED, HIGH);
    digitalWrite(GREEN_LED, LOW);
    digitalWrite(BLUE_LED, LOW);
  } else if (sample< 2000) {
    digitalWrite(RED_LED, LOW);
    digitalWrite(GREEN_LED, HIGH);
    digitalWrite(BLUE_LED, LOW);
  } else {
    digitalWrite(RED_LED, LOW);
    digitalWrite(GREEN_LED, LOW);
    digitalWrite(BLUE_LED, HIGH);
  }

  }
  peakToPeak = signalMax - signalMin;  // max - min = peak-peak amplitude
  Serial.println("peakTopeak=");
  Serial.println(peakToPeak);
  Serial.println();
  Serial.println("Volts=");
  double volts = (peakToPeak * 3.3) / 4096;  // convert to volts
  Serial.println(volts);
  delay(500);
}


//-----------------------------------------------------------------------------
//
// Power Measurement (Signal from microphone electret).
//
//  Read the comments and understand the program.
//  Replace the “????” with a suitable value before running the program.
// Step-1 : Goto ##TAG##1 and determine SAMPLE_FREQ and SIZE_BUFF
// Step-2 : Goto ##TAG##2 read and understand the sampling function
// Step-3 : Goto ##TAG##3 Translate your Matlab program to calculate the mean power
// Step-4 : Goto ##TAG##4 Set the microphone pin and determine the LOW, MAX and AVR level
// Step-5 : Goto ##TAG##5 Complete the main program loop()
//-----------------------------------------------------------------------------

// ##TAG##4 deb
#define	MICROPHONE_PIN	"????"                //define the pin number
#define threshold  4.2140e-10		      //define the power of silence 


// You must determine the power measured with no sound
// this is the low level value in the below line
#define		LOW_LEVEL		"????"

// You must determine the power measured with the maximum Sound
#define		MAX_LEVEL		"????"

// You have to choose the average acceptable value of power
// It can be nn% of the MAX_LEVEL
#define		AVR_LEVEL		"????"
// ##TAG##4 end


void setup()
//-----------------------------------------------------
// Initialization function 
//-----------------------------------------------------
{
	// Serial port baud rate = 9600 bauds
	Serial.begin(9600);
	// Initialize the sensor input as an analog input
	pinMode(MICROPHONE_PIN, INPUT);   // define pin number of microphone to read
}


float	Get_Soud_Power(void);


// ##TAG##5 deb
void loop()
//-----------------------------------------------------
// Main Fonction 
//-----------------------------------------------------
{
	// Déclaration de variables
	float SoundPower;		// puissance du Son

	Serial.println(" ");
	Serial.println("--- Sound Power Measurement ---");

	// call the function.
	SoundPower = Get_Soud_Power();

	// Display the result
	Serial.print(" Power = ");		Serial.println(SoundPower);
	if (SoundPower < LOW_LEVEL) {
		// Power is too low = no sound
		// display an explicit message and turn on the white LED
	}
	else if (SoundPower > AVR_LEVEL) {
		// Power is too high = sound is painful
		// display an explicit message and turn on the red LED
	}
	else {
		// acceptable power
		// display an explicit message and turn on the green LED
	}

	// wait 2 second
	delay(2000);
}
// ##TAG##5 end


// ##TAG##1 deb
// Define the sampling parameters
//---------------------------------------------------------------
//	Choose the sampling frequency (in KHz)
//#define		SAMPLE_FREQ	4000		/* frequency between 4 and 8 KHz		*/
//	Choose the size of samples buffer
//#define		SIZE_BUFF	1000		/* value between 1000 and 4000	*/
// ##TAG##1 end

//	Sampling period in micro-secondes
//#define		SAMPLE_PERIOD (1000/4000)  //(1000/SAMPLE_FREQ)
//	Signal samples Buffer 
//short	Buffer_Sample[SIZE_BUFF];

// Buffer de la Puissance instantannée du signal en flottant
//float	Power_Inst[SIZE_BUFF];







// ##TAG##2 deb
void Read_Samples(void)
//------------------------------------------------------------------------------
// No need to modify this function. Read and understand
//------------------------------------------------------------------------------
{
	short num_sample, val_sample;		
    unsigned long curtime, nextime;

	// See help of 'micros()' function in Energia
	// compute next sampling time (nextime)
	nextime = micros() + SAMPLE_PERIOD;
	num_sample = 0;
	while (num_sample < SIZE_BUFF) {
		// wait time of next sample (nextime)
		do {
			curtime = micros();
		} while (curtime < nextime);
		// read sample
		val_sample = analogRead(MICROPHONE_PIN);  
		Buffer_Sample[num_sample] = val_sample;
		num_sample++;
		// update next sample time
		nextime += SAMPLE_PERIOD;
	}
	return;
}
// ##TAG##2 end






// ##TAG##3 deb
int Get_Soud_Power()
{
	int power;
	float Buffer_Sample_Center[SIZE_BUFF];
	for(int i = 0; i < SIZE_BUFF; i++){
		power += Buffer_sample[i] * Buffer_sample[i];
	}
	
	flot power_mean = power / SIZE_BUFF;

	// center the signal
	
	for(i = 0; i < SIZE_BUFF; i++){
		float Buffer_Sample_Center[i] = Buffer_Sample [i] - power_mean; 
	}
	return power;
}

// ##TAG##3 end


    // display on the OLED
}
